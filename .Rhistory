## Generate beta
# mu = runif(p,-2,2) # betas: normal mean
# sig = 1/rgamma(p,1,0.5) # betas: normal variance
mu = c(0,-1)
sig = c(4,3)
rho=0.5
Sigma = matrix(rho, nrow=p, ncol=p) + diag(1-rho,p,p)
# X  = 3*abs(mvrnorm(n, rep(0,p), Sigma)) ##X dim: n*p
X=cbind(rep(1,n),seq(0.01,3,length.out=n))
## Generate Y
pres = X%*%(1/sig)
Y_sig = 1/pres
Y_mean = X%*%(mu/sig) / pres
## Generate observation of Y
Obs = matrix(nrow=num_obs,ncol=n)
for(i in 1:n)
{
Obs[,i]=rnorm(num_obs,Y_mean[i],sqrt(Y_sig[i]))
}
gg=melt(Obs)
ggplot(gg, aes(x=value)) +
geom_histogram(aes(y=..density..),bins=50) +
facet_wrap(~Var2,scales="free")
m = dim(Obs)[2]
ni = gg %>% group_by(Var2) %>% summarize(n=n())
ni = ni$n
## Description Statistics
m = dim(Obs)[2]
ni = gg %>% group_by(Var2) %>% summarize(n=n())
library(MASS)
library(reshape2)
library(ggplot2)
library(dplyr)
library(fda)
ni = gg %>% group_by(Var2) %>% summarize(n=n())
ni = ni$n
## Use B-spline to estimate the density first
L = 21 # Number of Bsplines
basisobj <- create.bspline.basis(range(Obs), L) # set up basis
nx = 100
tilde_y = matrix(nrow=m,ncol=nx)
xval <- seq(min(Obs),max(Obs),length.out = nx)
for(i in 1:m)
{
data = gg %>%
filter(Var2==i)
# set up initial value for Wfdobj
Wfd0 <- fd(matrix(0,L,1), basisobj)
WfdParobj <- fdPar(Wfd0, Lfdobj=2,lambda=0.1)
#  estimate density
denslist <- density.fd(data$value, WfdParobj)
#  plot density
wval <- eval.fd(xval, denslist$Wfdobj)
pval <- exp(wval)/denslist$C
tilde_y[i,] = pval
}
## Compare with true densities
par(mfrow=c(3,4))
for( i in 1:m)
{
data = gg %>%
filter(Var2==i)
hist(data$value,freq=FALSE)
curve(dnorm(x,Y_mean[i],sqrt(Y_sig[i])), xlim=range(Obs),add=TRUE)
points( xval,tilde_y[i,], type='l',col="red" )
}
getwd()
View(Obs)
par(mfrow=c(5,6))
for( i in 1:m)
{
data = gg %>%
filter(Var2==i)
hist(data$value,freq=FALSE)
curve(dnorm(x,Y_mean[i],sqrt(Y_sig[i])), xlim=range(Obs),add=TRUE)
points( xval,tilde_y[i,], type='l',col="red" )
}
rm(list = ls(all=TRUE));gc()
library(truncnorm)
library(fdapace)
library(nprobust)
library(logspline)
install.packages(c("fdapace", "logspline", "nprobust", "truncnorm"))
rm(list = ls(all=TRUE));gc()
library(truncnorm)
library(fdapace)
library(nprobust)
library(logspline)
set.seed(10000)
N <- 100
S <- 500
rbta <- c(0.8,0.5)
#bta1 <- 0.8
a=-3; b=3
delt <- 0.05
t <- seq(a,b,by=delt)
x1 <- runif(N,-1,0)
x2 <- seq(0.5,2,length.out = N)
#x2 <- abs(rnorm(N))
X1_par <- as.matrix(cbind(x1,x2))
# dim(X1)
x11 <- runif(N,0,1)
x22 <- rgamma(N,4,2)
X2_par <- as.matrix(cbind(x11,x22))
ypar <- NULL
yt <- matrix(0,N,length(t))
for (i in 1:N) {
xi1 <- X1_par[i,]
xi2 <- X2_par[i,]
ypari <- oplus_nor(rbta,xi1,xi2)
ypar <- rbind(ypar,ypari)
yt[i,] <- dtruncnorm(t,a,b,mean = ypari[1],sd=sqrt(ypari[2]))
}
install.packages("truncnorm")
install.packages("truncnorm")
# y_i=\beta_0(t)\oplus(x_i\odot\beta_1)(t) i=1,...,N
# \beta_j~N(\mu_j,\sigma_j) x_ eqaully spaced [0.01,10]
rm(list = ls(all=TRUE));gc()
library(truncnorm)
set.seed(0)
N <- 100
S <- 500
bta0 <- c(0,4)
bta1 <- c(-1,3)
a=-3; b=3
delt <- 0.01
t <- seq(a,b,by=delt)
x1 <- rep(1,N)
x2 <- seq(0.01,3.0,length.out = N)
#x2 <- abs(rnorm(N))
X <- as.matrix(cbind(x1,x2))
dim(X)
yS <- matrix(0,N,S)
ypar <- NULL
for (i in 1:N) {
xi <- X[i,]
ypari <- oplus_nor(xi,bta0,bta1)
ypar <- rbind(ypar,ypari)
yS[i,] <- rtruncnorm(S,a,b,mean = ypari[1],sd=sqrt(ypari[2]))
}
source('~/research/cell-level/jiangli\'s code/functions.R')
# y_i=\beta_0(t)\oplus(x_i\odot\beta_1)(t) i=1,...,N
# \beta_j~N(\mu_j,\sigma_j) x_ eqaully spaced [0.01,10]
rm(list = ls(all=TRUE));gc()
library(truncnorm)
set.seed(0)
N <- 100
S <- 500
bta0 <- c(0,4)
bta1 <- c(-1,3)
a=-3; b=3
delt <- 0.01
t <- seq(a,b,by=delt)
x1 <- rep(1,N)
x2 <- seq(0.01,3.0,length.out = N)
#x2 <- abs(rnorm(N))
X <- as.matrix(cbind(x1,x2))
dim(X)
yS <- matrix(0,N,S)
ypar <- NULL
for (i in 1:N) {
xi <- X[i,]
ypari <- oplus_nor(xi,bta0,bta1)
ypar <- rbind(ypar,ypari)
yS[i,] <- rtruncnorm(S,a,b,mean = ypari[1],sd=sqrt(ypari[2]))
}
source('~/research/cell-level/jiangli\'s code/functions.R')
library(truncnorm)
set.seed(0)
N <- 100
S <- 500
bta0 <- c(0,4)
bta1 <- c(-1,3)
a=-3; b=3
delt <- 0.01
t <- seq(a,b,by=delt)
x1 <- rep(1,N)
x2 <- seq(0.01,3.0,length.out = N)
#x2 <- abs(rnorm(N))
X <- as.matrix(cbind(x1,x2))
dim(X)
yS <- matrix(0,N,S)
ypar <- NULL
for (i in 1:N) {
xi <- X[i,]
ypari <- oplus_nor(xi,bta0,bta1)
ypar <- rbind(ypar,ypari)
yS[i,] <- rtruncnorm(S,a,b,mean = ypari[1],sd=sqrt(ypari[2]))
}
eypar <- matrix(0,N,2)
mu <- apply(yS, 1, mean)
sig <- apply(yS, 1, sd)
eypar[,1] <- mu
eypar[,2] <- sig^2
coef <- solve(t(X)%*%X)%*%t(X)
dim(coef)
hat_bta <- linearCom_nor(coef,eypar)
dim(ypar)
dim(hat_bta)
hat_bta
hat_y <- linearCom_nor(X,hat_bta)
dim(hat_y)
par(mfrow=c(1,3))
plot(t,dtruncnorm(t,a,b,mean=hat_bta[1,1],sd=sqrt(hat_bta[1,2])),type="l",main = "beta0",ylab = "density",xlab = "x")
lines(t,dtruncnorm(t,a,b,mean = bta0[1],sd=sqrt(bta0[2])),col="red")
plot(t,dtruncnorm(t,a,b,mean=hat_bta[2,1],sd=sqrt(hat_bta[2,2])),type="l",main = "beta1",ylab = "density",xlab = "x")
lines(t,dtruncnorm(t,a,b,mean = bta1[1],sd=sqrt(bta1[2])),col="red")
plot(t,dtruncnorm(t,a,b,mean=hat_y[1,1],sd=sqrt(hat_y[1,2])),type="l",main = "hat-y",ylab = "density",xlab = "x")
lines(t,dtruncnorm(t,a,b,mean = ypar[1,1],sd=sqrt(ypar[1,2])),col="red")
lines(t,dtruncnorm(t,a,b,mean = eypar[1,1],sd=sqrt(eypar[1,2])),col="blue")
ker_norm <- function(bw,t,x){
l <- length(x)
rlt <- 0
for (i in 1:l) {
rlt <- rlt+dnorm(t,mean=x[i],sd=bw)
}
rlt
}
bw <- 0.1
tidle_y <- ker_norm(bw,t,yS[i,])
hist(tidle_y)
eypar <- matrix(0,N,2)
mu <- apply(yS, 1, mean)
sig <- apply(yS, 1, sd)
eypar[,1] <- mu
eypar[,2] <- sig^2
coef <- solve(t(X)%*%X)%*%t(X)
dim(coef)
hat_bta <- linearCom_nor(coef,eypar)
dim(ypar)
dim(hat_bta)
hat_bta
hat_y <- linearCom_nor(X,hat_bta)
dim(hat_y)
par(mfrow=c(1,3))
plot(t,dtruncnorm(t,a,b,mean=hat_bta[1,1],sd=sqrt(hat_bta[1,2])),type="l",main = "beta0",ylab = "density",xlab = "x")
lines(t,dtruncnorm(t,a,b,mean = bta0[1],sd=sqrt(bta0[2])),col="red")
plot(t,dtruncnorm(t,a,b,mean=hat_bta[2,1],sd=sqrt(hat_bta[2,2])),type="l",main = "beta1",ylab = "density",xlab = "x")
lines(t,dtruncnorm(t,a,b,mean = bta1[1],sd=sqrt(bta1[2])),col="red")
plot(t,dtruncnorm(t,a,b,mean=hat_y[1,1],sd=sqrt(hat_y[1,2])),type="l",main = "hat-y",ylab = "density",xlab = "x")
lines(t,dtruncnorm(t,a,b,mean = ypar[1,1],sd=sqrt(ypar[1,2])),col="red")
lines(t,dtruncnorm(t,a,b,mean = eypar[1,1],sd=sqrt(eypar[1,2])),col="blue")
knitr::opts_chunk$set(echo = TRUE)
source('~/research/cell-level/paper/addnoisetosignal.R')
library(truncnorm)
n = 30 #Sample size
num_obs = 1000 #number of observations of each sample of Y
# Generate X
X=cbind(rep(1,n),seq(0.01,3,length.out=n))
# Generate X\beta(t)
mu = c(0,-1)
sig = c(4,3)
pres = X%*%(1/sig)
realY_sig = 1/pres
realY_mean = X%*%(mu/sig) / pres
## Add error function to X\beta(t), i.e. generate y(t)
# Suppose the interval is [-5,5]
Obs = matrix(nrow=num_obs,ncol=n)
for( i in 1:n)
{
# each curve is a truncated normal in [-5,5]
f = function(x){dtruncnorm(x,a=-5,b=5,mean=realY_mean[i], sd=sqrt(realY_sig[i]) )}
fpluseps = csterr(f, c(-5,5), Nx=1000,sd = 36)
f <- function(x) return( fv_eps(x,fpluseps$xval,fpluseps$obsdata) )
Obs[,i] = ricdf(num_obs, gicdf(f,min=-5,max=5))
}
gicdf <- function(fun,
min=-3.5,
max=3.5,
bins=1000,
nqratio=10,
grouping=mean,
...) {
# Generate an inverse CDF of an arbitrary function
fun <- match.fun(fun)
grouping <- match.fun(grouping)
# Number of points to draw
nq=nqratio*bins
# Draw indexes
qdraw <- seq(min, max,length.out=nq)
# Calculate proportional probability of each draw
pdraw <- fun(qdraw,...)
# Rescale probability sum to 1, rescale
pdraw <- pdraw/sum(pdraw)
# Calculate the cumulative probability at each qdraw
cpdraw <- cumsum(pdraw)
# Caculate the cumulative probability at each bin
pbin <- (1:bins)/bins
xbin <- NA*(1:bins)
for (i in 1:bins) {
xbin[i] <- grouping(qdraw[cpdraw<pbin[i]&cpdraw>0], na.rm = TRUE)
cpdraw[cpdraw<pbin[i]] <- 2
}
(draw.set <- list(digits=floor(log10(bins)), xbin=xbin, pbin=pbin))
}
# Draw from acdf
ricdf <- function(N, draw.set) {
digits <- draw.set$digits
pdraws <- ceiling(runif(N)*10^digits)/10^digits
draw.set$xbin[match(pdraws,draw.set$pbin)]
}
f_eps <- function(val,xp,yp){
temp = xp>val
rrange = which(temp==TRUE)[1]
lrange = rrange - 1
a1 = xp[lrange]
b1 = yp[lrange]
a2 = xp[rrange]
b2 = yp[rrange]
if(val==xp[length(xp)])
return(yp[length(xp)])
else
return( (b2-b1)/(a2-a1)*(val-a1)+b1 )
}
fv_eps <- function(newx,xp,yp)
{
len = length(newx)
newy = rep(0,len)
for(i in 1:len)
newy[i] = f_eps(newx[i],xp,yp)
return(newy)
}
source('~/research/cell-level/paper/addnoisetosignal.R')
library(truncnorm)
n = 30 #Sample size
num_obs = 1000 #number of observations of each sample of Y
# Generate X
X=cbind(rep(1,n),seq(0.01,3,length.out=n))
# Generate X\beta(t)
mu = c(0,-1)
sig = c(4,3)
pres = X%*%(1/sig)
realY_sig = 1/pres
realY_mean = X%*%(mu/sig) / pres
## Add error function to X\beta(t), i.e. generate y(t)
# Suppose the interval is [-5,5]
Obs = matrix(nrow=num_obs,ncol=n)
for( i in 1:n)
{
# each curve is a truncated normal in [-5,5]
f = function(x){dtruncnorm(x,a=-5,b=5,mean=realY_mean[i], sd=sqrt(realY_sig[i]) )}
fpluseps = csterr(f, c(-5,5), Nx=1000,sd = 36)
f <- function(x) return( fv_eps(x,fpluseps$xval,fpluseps$obsdata) )
Obs[,i] = ricdf(num_obs, gicdf(f,min=-5,max=5))
}
source('~/research/cell-level/paper/addnoisetosignal.R')
library(truncnorm)
library(fda)
n = 30 #Sample size
num_obs = 1000 #number of observations of each sample of Y
# Generate X
X=cbind(rep(1,n),seq(0.01,3,length.out=n))
# Generate X\beta(t)
mu = c(0,-1)
sig = c(4,3)
pres = X%*%(1/sig)
realY_sig = 1/pres
realY_mean = X%*%(mu/sig) / pres
## Add error function to X\beta(t), i.e. generate y(t)
# Suppose the interval is [-5,5]
Obs = matrix(nrow=num_obs,ncol=n)
for( i in 1:n)
{
# each curve is a truncated normal in [-5,5]
f = function(x){dtruncnorm(x,a=-5,b=5,mean=realY_mean[i], sd=sqrt(realY_sig[i]) )}
fpluseps = csterr(f, c(-5,5), Nx=1000,sd = 36)
f <- function(x) return( fv_eps(x,fpluseps$xval,fpluseps$obsdata) )
Obs[,i] = ricdf(num_obs, gicdf(f,min=-5,max=5))
}
## Plot the observed data
gg=melt(Obs)
library(MASS)
library(reshape2)
library(ggplot2)
library(dplyr)
library(fda)
## Plot the observed data
gg=melt(Obs)
ggplot(gg, aes(x=value)) +
geom_histogram(aes(y=..density..),bins=50) +
facet_wrap(~Var2,scales="free")
## Description Statistics
m = dim(Obs)[2]
ni = gg %>% group_by(Var2) %>% summarize(n=n())
ni = ni$n
##################################
####### Estimation ###############
##################################
## Use B-spline to estimate the density first
L = 21 # Number of Bsplines
basisobj <- create.bspline.basis(range(Obs), L) # set up basis
nx = 100
tilde_y = matrix(nrow=m,ncol=nx)
xval <- seq(min(Obs),max(Obs),length.out = nx)
for(i in 1:m)
{
data = gg %>%
filter(Var2==i)
# set up initial value for Wfdobj
Wfd0 <- fd(matrix(0,L,1), basisobj)
WfdParobj <- fdPar(Wfd0, Lfdobj=2,lambda=0.1)
#  estimate density
denslist <- density.fd(data$value, WfdParobj)
#  plot density
wval <- eval.fd(xval, denslist$Wfdobj)
pval <- exp(wval)/denslist$C
tilde_y[i,] = pval
}
##################################
###### Check the fitness #########
##################################
## Compare with true densities
par(mfrow=c(3,4))
for( i in 1:m)
{
data = gg %>%
filter(Var2==i)
hist(data$value,freq=FALSE)
curve(dtruncnorm(x,a=-5,b=5,realY_mean[i],sqrt(realY_sig[i])), xlim=range(Obs),add=TRUE)
points( xval,tilde_y[i,], type='l',col="red" )
}
logbeta = solve(t(X)%*%X,t(X)%*%log(tilde_y))
beta = exp(logbeta)
beta=diag(1/apply(beta,1,sum))%*%beta*nx/(max(Obs)-min(Obs))
par(mfrow=c(1,2))
curve(dnorm(x,0,2),xlim=range(Obs),main=expression(beta0))
points(xval,beta[1,],'l',col="red")
curve(dnorm(x,-1,sqrt(3)),xlim=range(Obs),main=expression(beta1))
points(xval,beta[2,],'l',col="red")
gtwd()
getwd()
install.packages("ks")
library(ks)
sam = 200
mus = rbind(c(-2,2),c(0,0),c(2,-2))
Sigma = rbind(diag(2),matrix(c(0.8,-0.72,-0.72,0.8),nrow = 2)+diag(2))
cwt = 3/11
props = c((1-cwt)/2, cwt, (1-cwt)/2)
x <- rmvnorm.mixt(n = samp, mu = mus, Sigma = Sigmas, props = props)
Sigmas = rbind(diag(2),matrix(c(0.8,-0.72,-0.72,0.8),nrow = 2)+diag(2))
x <- rmvnorm.mixt(n = samp, mu = mus, Sigma = Sigmas, props = props)
samp = 200
mus = rbind(c(-2,2),c(0,0),c(2,-2))
Sigmas = rbind(diag(2),matrix(c(0.8,-0.72,-0.72,0.8),nrow = 2)+diag(2))
cwt = 3/11
props = c((1-cwt)/2, cwt, (1-cwt)/2)
x <- rmvnorm.mixt(n = samp, mu = mus, Sigma = Sigmas, props = props)
Sigmas
mus
cwt
props
samp = 200
mus = rbind(c(-2,2),c(0,0),c(2,-2))
Sigmas = rbind(diag(2),matrix(c(0.8,-0.72,-0.72,0.8),nrow = 2)+diag(2))
cwt = 3/11
props = c((1-cwt)/2, cwt, (1-cwt)/2)
x <- rmvnorm.mixt(n = samp, mu = mus, Sigma = Sigmas, props = props)
Sigmas = rbind(diag(2),matrix(c(0.8,-0.72,-0.72,0.8),nrow = 2), diag(2))
cwt = 3/11
props = c((1-cwt)/2, cwt, (1-cwt)/2)
x <- rmvnorm.mixt(n = samp, mu = mus, Sigma = Sigmas, props = props)
Hpi1 <- Hpi(x = x, pilot = "amse", pre = "scale")
Hpi2 <- Hpi(x = x, pilot = "samse", pre = "scale")
Hpi3 <- Hpi(x = x, pilot = "amse", pre = "sphere")
Hpi4 <- Hpi(x = x, pilot = "samse", pre = "sphere")
Hpi5 <- Hpi.diag(x = x, pilot = "amse", pre = "scale")
Hpi6 <- Hpi.diag(x = x, pilot = "samse", pre = "scale")
kde(x = x, H = Hpi1)
res=kde(x = x, H = Hpi1)
View(res)
View(res)
Hlscv1 <- Hlscv(x = x)
Hlscv2 <- Hlscv.diag(x = x)
plot(res)
View(Hpi1)
View(res)
View(res)
dim(res$eval.points)
dim(res$eval.points[[1]])
res$eval.points[[1]]
length(res$eval.points[[1]])
A=diag(5)
imshow(A)
image(A)
image(res$estimate)
res[["cont"]][["98%"]]
res[["w"]]
res[["H"]]
install.packages("R.matlab")
library(R.matlab)
setwd("~/Desktop")
data = readMat('sample.mat')
View(data)
View(data)
data$vol
volume <- readMat('sample.mat')
setwd("~/Desktop/data2020")
volume <- readMat('sample.mat')
volume <- readMat('sample.mat')$vol
label  <- readMat('sample.mat')
View(label)
label  <- readMat('sample.mat')$vol
label  <- readMat('true_label.mat'
)
View(label)
label  <- readMat('true_label.mat')$md
label[label~=0] = 1
label[label!=0] = 1
dim(lable)
dim(label)
label[1,1,1]
label[10,10,10]
